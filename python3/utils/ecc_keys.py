#!/usr/bin/env python
# Generate a keypair that can be used by dpp and clinic applications. For dpp, the format of the private key is changed (DER/Hex)
# When this module is loaded, if the key pair does not exist, it is generated.

import os, sys
from OpenSSL import SSL

from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.backends.openssl.backend import backend
from cryptography.hazmat.primitives import serialization
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes
import hashlib
import binascii
from utils.syslogger import SysLogger
import base64

# Logfile is /tmp/protodpp.log
logger = SysLogger().logger()

# Default subscriber keys directory
folder = os.path.dirname(os.path.realpath(__file__))
keys_dir = os.path.join(folder, '../../keys')
key_name = "proto-pi"

try:
	os.mkdir(keys_dir)
except:
	pass

class ECCKeys():

	def __init__(self):

		if not self.load_keys():
			self.generate_keys()
			if not self.load_keys():
				logger.error("Unable to generate key pair")

	# Generate Private/Public Key Pair
	def generate_keys(self, name=key_name):

		# For now, we cannot have '/' in public key
		while True:
			private_key = ec.generate_private_key(ec.SECP256R1(), backend)
			private_pem = self.private_key_pem(private_key)
			private_pem_chars = private_pem.decode("utf-8")

			# We only generate this compressed public key to see if there will be a slash in it. dpp_bootstrap_gen will 
			# generate an identical compressed public key in the uri from the hex encoded dpp private key
			cmd = 'echo "'+private_pem_chars+'" | openssl ec -pubout -outform PEM -param_enc named_curve -conv_form compressed'
			cpem = os.popen(cmd).read()

			if not "/" in cpem:
				break

			# Try again
			#logger.info("key contains slash")

		# Here with a key whose compressed public key does not contain a slash
		# Save public/private keys in PEM format
		with open(keys_dir+'/'+name, "wb") as f:
			f.write(self.private_key_pem(private_key))

		with open(keys_dir+'/'+name+".pub", "wb") as f:
			f.write(self.public_key_pem(private_key.public_key()))

		## DPP ##
		# Extract and encode the key portion of the private key PEM, as required by dpp_bootstrap_gen
		cmd = 'echo "'+private_pem_chars+'" | openssl ec -outform DER|xxd -p -c 256'
		result = os.popen(cmd).read()
		lines = result.split('\n')

		hex_chars = ""
		for line in lines:
			if not "EC key" in line:
				hex_chars += line

		logger.info("dpp private key (hex): "+hex_chars)
		# This is what is returned in uri by dpp_bootstrap_gen
		logger.info("dpp public key (compressed): "+cpem)


		with open(keys_dir+'/'+name+".dpp", "wb") as f:
			f.write(hex_chars.encode('utf-8'))

		return private_key

	# new keys can also be regenerated by deleting the key files and restarting the application
	def regenerate(self):
		self.generate_keys()
		self.load_keys()

	def delete_keys(self, name=None):
		if not name:
			name = key_name
		try:
			os.remove(keys_dir+'/'+name)
			os.remove(keys_dir+'/'+name+".pub")
			os.remove(keys_dir+'/'+name+".dpp")
		except Exception as e:
			pass

	def keys_exists(self, name):
		return (os.path.isfile(keys_dir+'/'+name) and os.path.isfile(keys_dir+'/'+name+'.pub') and os.path.isfile(keys_dir+'/'+name+'.dpp')) 

	# Generate PEM format for private key
	def private_key_pem(self, private_key=None):
		if not private_key:
			private_key = self.private_key
		return private_key.private_bytes(
			encoding=serialization.Encoding.PEM,
			format=serialization.PrivateFormat.TraditionalOpenSSL,
			encryption_algorithm=serialization.NoEncryption())

	# Generate PEM format for public key
	def public_key_pem(self, public_key=None):
		if not public_key:
			public_key = self.public_key
		return public_key.public_bytes(
			encoding=serialization.Encoding.PEM,
			format=serialization.PublicFormat.SubjectPublicKeyInfo)

	# Generate a signed CSR
	def generate_csr(self, csr_name, key=None):
		if not key:
			key = self.private_key

		csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([
			x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
			x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u"CO"),
			x509.NameAttribute(NameOID.LOCALITY_NAME, u"Louisville"),
			x509.NameAttribute(NameOID.ORGANIZATION_NAME, u"CableLabs"),
			x509.NameAttribute(NameOID.COMMON_NAME, u"medicalDevice"),
		])
		# Sign the CSR with our private key.
		).sign(key, hashes.SHA256(), backend)

		# Write our CSR out to disk.
		with open(keys_dir+'/'+csr_name+".pem", "wb") as f:
			f.write(csr.public_bytes(serialization.Encoding.PEM))

		self.csr = csr
		return csr

	def encoded_csr_base64(self, csr=None):
		if csr == None:
			csr = self.csr
		csr_bytes = self.csr.public_bytes(serialization.Encoding.PEM)
		return base64.b64encode(csr_bytes).decode('utf-8')

	# Generate a hash of the public key for use as deviceID
	def public_key_hash(self, public_key = None):
		if not public_key:
			public_key = self.public_key
		try:
			return hashlib.sha256(self.public_key_pem(public_key)).hexdigest()
		except:
			raise
			return None

	# Load keys 
	def load_keys(self):
		self.private_key = self.load_private_key()
		self.public_key = self.load_public_key()
		self.private_key_dpp = self.load_private_key_dpp()
		return (self.public_key and self.private_key and self.private_key_dpp)

	# Load private key object
	def load_private_key(self, name=key_name):
		try:
			with open(keys_dir+'/'+name, "rb") as key_file:
				key = serialization.load_pem_private_key(
					key_file.read(),
					password=None,
					backend=backend
				)
				return key
		except:
			logger.error("failed to load private key")
			return None

	# Load public key object
	def load_public_key(self, name=key_name):
		try:
			with open(keys_dir+'/'+name+'.pub', "rb") as key_file:
				key = serialization.load_pem_public_key(
					key_file.read(),
					backend=backend
				)
				return key
		except:
			logger.error("failed to load public key")
			return None

	# load private key string (der/hex encoded)
	def load_private_key_dpp(self, name=key_name):
		try:
			with open(keys_dir+'/'+name+'.dpp', "rb") as key_file:
				return key_file.read()
		except:
			logger.error("failed to load private key (dpp string)")
			return None

ecc_keys = ECCKeys()

if __name__ == '__main__':

	ecc_keys.generate_csr("my_csr")
	print("csr: {}".format(ecc_keys.encoded_csr_base64()))
	print( "deviceID: {}".format(ecc_keys.public_key_hash()))


